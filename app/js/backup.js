$(document).ready(function () {
    //Menu button on click event

    $('.mobile-nav-button').on('click', function() {
        // Toggles a class on the menu button to transform the burger menu into a cross
        $( ".mobile-nav-button .mobile-nav-button__line:nth-of-type(1)" ).toggleClass( "mobile-nav-button__line--1");
        $( ".mobile-nav-button .mobile-nav-button__line:nth-of-type(2)" ).toggleClass( "mobile-nav-button__line--2");
        $( ".mobile-nav-button .mobile-nav-button__line:nth-of-type(3)" ).toggleClass( "mobile-nav-button__line--3");

        // Toggles a class that slides the menu into view on the screen
        $('.mobile-menu').toggleClass('mobile-menu--open');
        return false;
    });
});

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Parallax = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
        /*
        object-assign
        (c) Sindre Sorhus
        @license MIT
        */

        'use strict';
        /* eslint-disable no-unused-vars */
        var getOwnPropertySymbols = Object.getOwnPropertySymbols;
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var propIsEnumerable = Object.prototype.propertyIsEnumerable;

        function toObject(val) {
            if (val === null || val === undefined) {
                throw new TypeError('Object.assign cannot be called with null or undefined');
            }

            return Object(val);
        }

        function shouldUseNative() {
            try {
                if (!Object.assign) {
                    return false;
                }

                // Detect buggy property enumeration order in older V8 versions.

                // https://bugs.chromium.org/p/v8/issues/detail?id=4118
                var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
                test1[5] = 'de';
                if (Object.getOwnPropertyNames(test1)[0] === '5') {
                    return false;
                }

                // https://bugs.chromium.org/p/v8/issues/detail?id=3056
                var test2 = {};
                for (var i = 0; i < 10; i++) {
                    test2['_' + String.fromCharCode(i)] = i;
                }
                var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
                    return test2[n];
                });
                if (order2.join('') !== '0123456789') {
                    return false;
                }

                // https://bugs.chromium.org/p/v8/issues/detail?id=3056
                var test3 = {};
                'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
                    test3[letter] = letter;
                });
                if (Object.keys(Object.assign({}, test3)).join('') !==
                    'abcdefghijklmnopqrst') {
                    return false;
                }

                return true;
            } catch (err) {
                // We don't expect any of the above to throw, but better to be safe.
                return false;
            }
        }

        module.exports = shouldUseNative() ? Object.assign : function (target, source) {
            var from;
            var to = toObject(target);
            var symbols;

            for (var s = 1; s < arguments.length; s++) {
                from = Object(arguments[s]);

                for (var key in from) {
                    if (hasOwnProperty.call(from, key)) {
                        to[key] = from[key];
                    }
                }

                if (getOwnPropertySymbols) {
                    symbols = getOwnPropertySymbols(from);
                    for (var i = 0; i < symbols.length; i++) {
                        if (propIsEnumerable.call(from, symbols[i])) {
                            to[symbols[i]] = from[symbols[i]];
                        }
                    }
                }
            }

            return to;
        };

    },{}],2:[function(require,module,exports){
        (function (process){
// Generated by CoffeeScript 1.12.2
            (function() {
                var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

                if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
                    module.exports = function() {
                        return performance.now();
                    };
                } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
                    module.exports = function() {
                        return (getNanoSeconds() - nodeLoadTime) / 1e6;
                    };
                    hrtime = process.hrtime;
                    getNanoSeconds = function() {
                        var hr;
                        hr = hrtime();
                        return hr[0] * 1e9 + hr[1];
                    };
                    moduleLoadTime = getNanoSeconds();
                    upTime = process.uptime() * 1e9;
                    nodeLoadTime = moduleLoadTime - upTime;
                } else if (Date.now) {
                    module.exports = function() {
                        return Date.now() - loadTime;
                    };
                    loadTime = Date.now();
                } else {
                    module.exports = function() {
                        return new Date().getTime() - loadTime;
                    };
                    loadTime = new Date().getTime();
                }

            }).call(this);



        }).call(this,require('_process'))
    },{"_process":3}],3:[function(require,module,exports){
// shim for using process in browser
        var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

        var cachedSetTimeout;
        var cachedClearTimeout;

        function defaultSetTimout() {
            throw new Error('setTimeout has not been defined');
        }
        function defaultClearTimeout () {
            throw new Error('clearTimeout has not been defined');
        }
        (function () {
            try {
                if (typeof setTimeout === 'function') {
                    cachedSetTimeout = setTimeout;
                } else {
                    cachedSetTimeout = defaultSetTimout;
                }
            } catch (e) {
                cachedSetTimeout = defaultSetTimout;
            }
            try {
                if (typeof clearTimeout === 'function') {
                    cachedClearTimeout = clearTimeout;
                } else {
                    cachedClearTimeout = defaultClearTimeout;
                }
            } catch (e) {
                cachedClearTimeout = defaultClearTimeout;
            }
        } ())
        function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
                //normal enviroments in sane situations
                return setTimeout(fun, 0);
            }
            // if setTimeout wasn't available but was latter defined
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                cachedSetTimeout = setTimeout;
                return setTimeout(fun, 0);
            }
            try {
                // when when somebody has screwed with setTimeout but no I.E. maddness
                return cachedSetTimeout(fun, 0);
            } catch(e){
                try {
                    // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                    return cachedSetTimeout.call(null, fun, 0);
                } catch(e){
                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                    return cachedSetTimeout.call(this, fun, 0);
                }
            }


        }
        function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
                //normal enviroments in sane situations
                return clearTimeout(marker);
            }
            // if clearTimeout wasn't available but was latter defined
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                cachedClearTimeout = clearTimeout;
                return clearTimeout(marker);
            }
            try {
                // when when somebody has screwed with setTimeout but no I.E. maddness
                return cachedClearTimeout(marker);
            } catch (e){
                try {
                    // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                    return cachedClearTimeout.call(null, marker);
                } catch (e){
                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                    // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                    return cachedClearTimeout.call(this, marker);
                }
            }



        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;

        function cleanUpNextTick() {
            if (!draining || !currentQueue) {
                return;
            }
            draining = false;
            if (currentQueue.length) {
                queue = currentQueue.concat(queue);
            } else {
                queueIndex = -1;
            }
            if (queue.length) {
                drainQueue();
            }
        }

        function drainQueue() {
            if (draining) {
                return;
            }
            var timeout = runTimeout(cleanUpNextTick);
            draining = true;

            var len = queue.length;
            while(len) {
                currentQueue = queue;
                queue = [];
                while (++queueIndex < len) {
                    if (currentQueue) {
                        currentQueue[queueIndex].run();
                    }
                }
                queueIndex = -1;
                len = queue.length;
            }
            currentQueue = null;
            draining = false;
            runClearTimeout(timeout);
        }

        process.nextTick = function (fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
                for (var i = 1; i < arguments.length; i++) {
                    args[i - 1] = arguments[i];
                }
            }
            queue.push(new Item(fun, args));
            if (queue.length === 1 && !draining) {
                runTimeout(drainQueue);
            }
        };

// v8 likes predictible objects
        function Item(fun, array) {
            this.fun = fun;
            this.array = array;
        }
        Item.prototype.run = function () {
            this.fun.apply(null, this.array);
        };
        process.title = 'browser';
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = ''; // empty string to avoid regexp issues
        process.versions = {};

        function noop() {}

        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.prependListener = noop;
        process.prependOnceListener = noop;

        process.listeners = function (name) { return [] }

        process.binding = function (name) {
            throw new Error('process.binding is not supported');
        };

        process.cwd = function () { return '/' };
        process.chdir = function (dir) {
            throw new Error('process.chdir is not supported');
        };
        process.umask = function() { return 0; };

    },{}],4:[function(require,module,exports){
        (function (global){
            var now = require('performance-now')
                , root = typeof window === 'undefined' ? global : window
                , vendors = ['moz', 'webkit']
                , suffix = 'AnimationFrame'
                , raf = root['request' + suffix]
                , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]

            for(var i = 0; !raf && i < vendors.length; i++) {
                raf = root[vendors[i] + 'Request' + suffix]
                caf = root[vendors[i] + 'Cancel' + suffix]
                    || root[vendors[i] + 'CancelRequest' + suffix]
            }

// Some versions of FF have rAF but not cAF
            if(!raf || !caf) {
                var last = 0
                    , id = 0
                    , queue = []
                    , frameDuration = 1000 / 60

                raf = function(callback) {
                    if(queue.length === 0) {
                        var _now = now()
                            , next = Math.max(0, frameDuration - (_now - last))
                        last = next + _now
                        setTimeout(function() {
                            var cp = queue.slice(0)
                            // Clear queue here to prevent
                            // callbacks from appending listeners
                            // to the current frame's queue
                            queue.length = 0
                            for(var i = 0; i < cp.length; i++) {
                                if(!cp[i].cancelled) {
                                    try{
                                        cp[i].callback(last)
                                    } catch(e) {
                                        setTimeout(function() { throw e }, 0)
                                    }
                                }
                            }
                        }, Math.round(next))
                    }
                    queue.push({
                        handle: ++id,
                        callback: callback,
                        cancelled: false
                    })
                    return id
                }

                caf = function(handle) {
                    for(var i = 0; i < queue.length; i++) {
                        if(queue[i].handle === handle) {
                            queue[i].cancelled = true
                        }
                    }
                }
            }

            module.exports = function(fn) {
                // Wrap in a new function to prevent
                // `cancel` potentially being assigned
                // to the native rAF function
                return raf.call(root, fn)
            }
            module.exports.cancel = function() {
                caf.apply(root, arguments)
            }
            module.exports.polyfill = function() {
                root.requestAnimationFrame = raf
                root.cancelAnimationFrame = caf
            }

        }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    },{"performance-now":2}],5:[function(require,module,exports){
        'use strict';

        var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        /**
         * Parallax.js
         * @author Matthew Wagerfield - @wagerfield, RenÃ© Roth - mail@reneroth.org
         * @description Creates a parallax effect between an array of layers,
         *              driving the motion from the gyroscope output of a smartdevice.
         *              If no gyroscope is available, the cursor position is used.
         */

        var rqAnFr = require('raf');
        var objectAssign = require('object-assign');

        var helpers = {
            propertyCache: {},
            vendors: [null, ['-webkit-', 'webkit'], ['-moz-', 'Moz'], ['-o-', 'O'], ['-ms-', 'ms']],

            clamp: function clamp(value, min, max) {
                return min < max ? value < min ? min : value > max ? max : value : value < max ? max : value > min ? min : value;
            },
            data: function data(element, name) {
                return helpers.deserialize(element.getAttribute('data-' + name));
            },
            deserialize: function deserialize(value) {
                if (value === 'true') {
                    return true;
                } else if (value === 'false') {
                    return false;
                } else if (value === 'null') {
                    return null;
                } else if (!isNaN(parseFloat(value)) && isFinite(value)) {
                    return parseFloat(value);
                } else {
                    return value;
                }
            },
            camelCase: function camelCase(value) {
                return value.replace(/-+(.)?/g, function (match, character) {
                    return character ? character.toUpperCase() : '';
                });
            },
            accelerate: function accelerate(element) {
                helpers.css(element, 'transform', 'translate3d(0,0,0) rotate(0.0001deg)');
                helpers.css(element, 'transform-style', 'preserve-3d');
                helpers.css(element, 'backface-visibility', 'hidden');
            },
            transformSupport: function transformSupport(value) {
                var element = document.createElement('div'),
                    propertySupport = false,
                    propertyValue = null,
                    featureSupport = false,
                    cssProperty = null,
                    jsProperty = null;
                for (var i = 0, l = helpers.vendors.length; i < l; i++) {
                    if (helpers.vendors[i] !== null) {
                        cssProperty = helpers.vendors[i][0] + 'transform';
                        jsProperty = helpers.vendors[i][1] + 'Transform';
                    } else {
                        cssProperty = 'transform';
                        jsProperty = 'transform';
                    }
                    if (element.style[jsProperty] !== undefined) {
                        propertySupport = true;
                        break;
                    }
                }
                switch (value) {
                    case '2D':
                        featureSupport = propertySupport;
                        break;
                    case '3D':
                        if (propertySupport) {
                            var body = document.body || document.createElement('body'),
                                documentElement = document.documentElement,
                                documentOverflow = documentElement.style.overflow,
                                isCreatedBody = false;

                            if (!document.body) {
                                isCreatedBody = true;
                                documentElement.style.overflow = 'hidden';
                                documentElement.appendChild(body);
                                body.style.overflow = 'hidden';
                                body.style.background = '';
                            }

                            body.appendChild(element);
                            element.style[jsProperty] = 'translate3d(1px,1px,1px)';
                            propertyValue = window.getComputedStyle(element).getPropertyValue(cssProperty);
                            featureSupport = propertyValue !== undefined && propertyValue.length > 0 && propertyValue !== 'none';
                            documentElement.style.overflow = documentOverflow;
                            body.removeChild(element);

                            if (isCreatedBody) {
                                body.removeAttribute('style');
                                body.parentNode.removeChild(body);
                            }
                        }
                        break;
                }
                return featureSupport;
            },
            css: function css(element, property, value) {
                var jsProperty = helpers.propertyCache[property];
                if (!jsProperty) {
                    for (var i = 0, l = helpers.vendors.length; i < l; i++) {
                        if (helpers.vendors[i] !== null) {
                            jsProperty = helpers.camelCase(helpers.vendors[i][1] + '-' + property);
                        } else {
                            jsProperty = property;
                        }
                        if (element.style[jsProperty] !== undefined) {
                            helpers.propertyCache[property] = jsProperty;
                            break;
                        }
                    }
                }
                element.style[jsProperty] = value;
            }
        };

        var MAGIC_NUMBER = 30,
            DEFAULTS = {
                relativeInput: false,
                clipRelativeInput: false,
                inputElement: null,
                hoverOnly: false,
                calibrationThreshold: 100,
                calibrationDelay: 500,
                supportDelay: 500,
                calibrateX: false,
                calibrateY: true,
                invertX: true,
                invertY: true,
                limitX: false,
                limitY: false,
                scalarX: 10.0,
                scalarY: 10.0,
                frictionX: 0.1,
                frictionY: 0.1,
                originX: 0.5,
                originY: 0.5,
                pointerEvents: false,
                precision: 1,
                onReady: null,
                selector: null
            };

        var Parallax = function () {
            function Parallax(element, options) {
                _classCallCheck(this, Parallax);

                this.element = element;

                var data = {
                    calibrateX: helpers.data(this.element, 'calibrate-x'),
                    calibrateY: helpers.data(this.element, 'calibrate-y'),
                    invertX: helpers.data(this.element, 'invert-x'),
                    invertY: helpers.data(this.element, 'invert-y'),
                    limitX: helpers.data(this.element, 'limit-x'),
                    limitY: helpers.data(this.element, 'limit-y'),
                    scalarX: helpers.data(this.element, 'scalar-x'),
                    scalarY: helpers.data(this.element, 'scalar-y'),
                    frictionX: helpers.data(this.element, 'friction-x'),
                    frictionY: helpers.data(this.element, 'friction-y'),
                    originX: helpers.data(this.element, 'origin-x'),
                    originY: helpers.data(this.element, 'origin-y'),
                    pointerEvents: helpers.data(this.element, 'pointer-events'),
                    precision: helpers.data(this.element, 'precision'),
                    relativeInput: helpers.data(this.element, 'relative-input'),
                    clipRelativeInput: helpers.data(this.element, 'clip-relative-input'),
                    hoverOnly: helpers.data(this.element, 'hover-only'),
                    inputElement: document.querySelector(helpers.data(this.element, 'input-element')),
                    selector: helpers.data(this.element, 'selector')
                };

                for (var key in data) {
                    if (data[key] === null) {
                        delete data[key];
                    }
                }

                objectAssign(this, DEFAULTS, data, options);

                if (!this.inputElement) {
                    this.inputElement = this.element;
                }

                this.calibrationTimer = null;
                this.calibrationFlag = true;
                this.enabled = false;
                this.depthsX = [];
                this.depthsY = [];
                this.raf = null;

                this.bounds = null;
                this.elementPositionX = 0;
                this.elementPositionY = 0;
                this.elementWidth = 0;
                this.elementHeight = 0;

                this.elementCenterX = 0;
                this.elementCenterY = 0;

                this.elementRangeX = 0;
                this.elementRangeY = 0;

                this.calibrationX = 0;
                this.calibrationY = 0;

                this.inputX = 0;
                this.inputY = 0;

                this.motionX = 0;
                this.motionY = 0;

                this.velocityX = 0;
                this.velocityY = 0;

                this.onMouseMove = this.onMouseMove.bind(this);
                this.onDeviceOrientation = this.onDeviceOrientation.bind(this);
                this.onDeviceMotion = this.onDeviceMotion.bind(this);
                this.onOrientationTimer = this.onOrientationTimer.bind(this);
                this.onMotionTimer = this.onMotionTimer.bind(this);
                this.onCalibrationTimer = this.onCalibrationTimer.bind(this);
                this.onAnimationFrame = this.onAnimationFrame.bind(this);
                this.onWindowResize = this.onWindowResize.bind(this);

                this.windowWidth = null;
                this.windowHeight = null;
                this.windowCenterX = null;
                this.windowCenterY = null;
                this.windowRadiusX = null;
                this.windowRadiusY = null;
                this.portrait = false;
                this.desktop = !navigator.userAgent.match(/(iPhone|iPod|iPad|Android|BlackBerry|BB10|mobi|tablet|opera mini|nexus 7)/i);
                this.motionSupport = !!window.DeviceMotionEvent && !this.desktop;
                this.orientationSupport = !!window.DeviceOrientationEvent && !this.desktop;
                this.orientationStatus = 0;
                this.motionStatus = 0;

                this.initialise();
            }

            _createClass(Parallax, [{
                key: 'initialise',
                value: function initialise() {
                    if (this.transform2DSupport === undefined) {
                        this.transform2DSupport = helpers.transformSupport('2D');
                        this.transform3DSupport = helpers.transformSupport('3D');
                    }

                    // Configure Context Styles
                    if (this.transform3DSupport) {
                        helpers.accelerate(this.element);
                    }

                    var style = window.getComputedStyle(this.element);
                    if (style.getPropertyValue('position') === 'static') {
                        this.element.style.position = 'relative';
                    }

                    // Pointer events
                    if (!this.pointerEvents) {
                        this.element.style.pointerEvents = 'none';
                    }

                    // Setup
                    this.updateLayers();
                    this.updateDimensions();
                    this.enable();
                    this.queueCalibration(this.calibrationDelay);
                }
            }, {
                key: 'doReadyCallback',
                value: function doReadyCallback() {
                    if (this.onReady) {
                        this.onReady();
                    }
                }
            }, {
                key: 'updateLayers',
                value: function updateLayers() {
                    if (this.selector) {
                        this.layers = this.element.querySelectorAll(this.selector);
                    } else {
                        this.layers = this.element.children;
                    }

                    if (!this.layers.length) {
                        console.warn('ParallaxJS: Your scene does not have any layers.');
                    }

                    this.depthsX = [];
                    this.depthsY = [];

                    for (var index = 0; index < this.layers.length; index++) {
                        var layer = this.layers[index];

                        if (this.transform3DSupport) {
                            helpers.accelerate(layer);
                        }

                        // layer.style.position = index ? 'absolute' : 'relative';
                        // layer.style.display = 'block';
                        // layer.style.left = 0;
                        // layer.style.top = 0;

                        var depth = helpers.data(layer, 'depth') || 0;
                        this.depthsX.push(helpers.data(layer, 'depth-x') || depth);
                        this.depthsY.push(helpers.data(layer, 'depth-y') || depth);
                    }
                }
            }, {
                key: 'updateDimensions',
                value: function updateDimensions() {
                    this.windowWidth = window.innerWidth;
                    this.windowHeight = window.innerHeight;
                    this.windowCenterX = this.windowWidth * this.originX;
                    this.windowCenterY = this.windowHeight * this.originY;
                    this.windowRadiusX = Math.max(this.windowCenterX, this.windowWidth - this.windowCenterX);
                    this.windowRadiusY = Math.max(this.windowCenterY, this.windowHeight - this.windowCenterY);
                }
            }, {
                key: 'updateBounds',
                value: function updateBounds() {
                    this.bounds = this.inputElement.getBoundingClientRect();
                    this.elementPositionX = this.bounds.left;
                    this.elementPositionY = this.bounds.top;
                    this.elementWidth = this.bounds.width;
                    this.elementHeight = this.bounds.height;
                    this.elementCenterX = this.elementWidth * this.originX;
                    this.elementCenterY = this.elementHeight * this.originY;
                    this.elementRangeX = Math.max(this.elementCenterX, this.elementWidth - this.elementCenterX);
                    this.elementRangeY = Math.max(this.elementCenterY, this.elementHeight - this.elementCenterY);
                }
            }, {
                key: 'queueCalibration',
                value: function queueCalibration(delay) {
                    clearTimeout(this.calibrationTimer);
                    this.calibrationTimer = setTimeout(this.onCalibrationTimer, delay);
                }
            }, {
                key: 'enable',
                value: function enable() {
                    if (this.enabled) {
                        return;
                    }
                    this.enabled = true;

                    if (this.orientationSupport) {
                        this.portrait = false;
                        window.addEventListener('deviceorientation', this.onDeviceOrientation);
                        this.detectionTimer = setTimeout(this.onOrientationTimer, this.supportDelay);
                    } else if (this.motionSupport) {
                        this.portrait = false;
                        window.addEventListener('devicemotion', this.onDeviceMotion);
                        this.detectionTimer = setTimeout(this.onMotionTimer, this.supportDelay);
                    } else {
                        this.calibrationX = 0;
                        this.calibrationY = 0;
                        this.portrait = false;
                        window.addEventListener('mousemove', this.onMouseMove);
                        this.doReadyCallback();
                    }

                    window.addEventListener('resize', this.onWindowResize);
                    this.raf = rqAnFr(this.onAnimationFrame);
                }
            }, {
                key: 'disable',
                value: function disable() {
                    if (!this.enabled) {
                        return;
                    }
                    this.enabled = false;

                    if (this.orientationSupport) {
                        window.removeEventListener('deviceorientation', this.onDeviceOrientation);
                    } else if (this.motionSupport) {
                        window.removeEventListener('devicemotion', this.onDeviceMotion);
                    } else {
                        window.removeEventListener('mousemove', this.onMouseMove);
                    }

                    window.removeEventListener('resize', this.onWindowResize);
                    rqAnFr.cancel(this.raf);
                }
            }, {
                key: 'calibrate',
                value: function calibrate(x, y) {
                    this.calibrateX = x === undefined ? this.calibrateX : x;
                    this.calibrateY = y === undefined ? this.calibrateY : y;
                }
            }, {
                key: 'invert',
                value: function invert(x, y) {
                    this.invertX = x === undefined ? this.invertX : x;
                    this.invertY = y === undefined ? this.invertY : y;
                }
            }, {
                key: 'friction',
                value: function friction(x, y) {
                    this.frictionX = x === undefined ? this.frictionX : x;
                    this.frictionY = y === undefined ? this.frictionY : y;
                }
            }, {
                key: 'scalar',
                value: function scalar(x, y) {
                    this.scalarX = x === undefined ? this.scalarX : x;
                    this.scalarY = y === undefined ? this.scalarY : y;
                }
            }, {
                key: 'limit',
                value: function limit(x, y) {
                    this.limitX = x === undefined ? this.limitX : x;
                    this.limitY = y === undefined ? this.limitY : y;
                }
            }, {
                key: 'origin',
                value: function origin(x, y) {
                    this.originX = x === undefined ? this.originX : x;
                    this.originY = y === undefined ? this.originY : y;
                }
            }, {
                key: 'setInputElement',
                value: function setInputElement(element) {
                    this.inputElement = element;
                    this.updateDimensions();
                }
            }, {
                key: 'setPosition',
                value: function setPosition(element, x, y) {
                    x = x.toFixed(this.precision) + 'px';
                    y = y.toFixed(this.precision) + 'px';
                    if (this.transform3DSupport) {
                        helpers.css(element, 'transform', 'translate3d(' + x + ',' + y + ',0)');
                    } else if (this.transform2DSupport) {
                        helpers.css(element, 'transform', 'translate(' + x + ',' + y + ')');
                    } else {
                        element.style.left = x;
                        element.style.top = y;
                    }
                }
            }, {
                key: 'onOrientationTimer',
                value: function onOrientationTimer() {
                    if (this.orientationSupport && this.orientationStatus === 0) {
                        this.disable();
                        this.orientationSupport = false;
                        this.enable();
                    } else {
                        this.doReadyCallback();
                    }
                }
            }, {
                key: 'onMotionTimer',
                value: function onMotionTimer() {
                    if (this.motionSupport && this.motionStatus === 0) {
                        this.disable();
                        this.motionSupport = false;
                        this.enable();
                    } else {
                        this.doReadyCallback();
                    }
                }
            }, {
                key: 'onCalibrationTimer',
                value: function onCalibrationTimer() {
                    this.calibrationFlag = true;
                }
            }, {
                key: 'onWindowResize',
                value: function onWindowResize() {
                    this.updateDimensions();
                }
            }, {
                key: 'onAnimationFrame',
                value: function onAnimationFrame() {
                    this.updateBounds();
                    var calibratedInputX = this.inputX - this.calibrationX,
                        calibratedInputY = this.inputY - this.calibrationY;
                    if (Math.abs(calibratedInputX) > this.calibrationThreshold || Math.abs(calibratedInputY) > this.calibrationThreshold) {
                        this.queueCalibration(0);
                    }
                    if (this.portrait) {
                        this.motionX = this.calibrateX ? calibratedInputY : this.inputY;
                        this.motionY = this.calibrateY ? calibratedInputX : this.inputX;
                    } else {
                        this.motionX = this.calibrateX ? calibratedInputX : this.inputX;
                        this.motionY = this.calibrateY ? calibratedInputY : this.inputY;
                    }
                    this.motionX *= this.elementWidth * (this.scalarX / 100);
                    this.motionY *= this.elementHeight * (this.scalarY / 100);
                    if (!isNaN(parseFloat(this.limitX))) {
                        this.motionX = helpers.clamp(this.motionX, -this.limitX, this.limitX);
                    }
                    if (!isNaN(parseFloat(this.limitY))) {
                        this.motionY = helpers.clamp(this.motionY, -this.limitY, this.limitY);
                    }
                    this.velocityX += (this.motionX - this.velocityX) * this.frictionX;
                    this.velocityY += (this.motionY - this.velocityY) * this.frictionY;
                    for (var index = 0; index < this.layers.length; index++) {
                        var layer = this.layers[index],
                            depthX = this.depthsX[index],
                            depthY = this.depthsY[index],
                            xOffset = this.velocityX * (depthX * (this.invertX ? -1 : 1)),
                            yOffset = this.velocityY * (depthY * (this.invertY ? -1 : 1));
                        this.setPosition(layer, xOffset, yOffset);
                    }
                    this.raf = rqAnFr(this.onAnimationFrame);
                }
            }, {
                key: 'rotate',
                value: function rotate(beta, gamma) {
                    // Extract Rotation
                    var x = (beta || 0) / MAGIC_NUMBER,
                        //  -90 :: 90
                        y = (gamma || 0) / MAGIC_NUMBER; // -180 :: 180

                    // Detect Orientation Change
                    var portrait = this.windowHeight > this.windowWidth;
                    if (this.portrait !== portrait) {
                        this.portrait = portrait;
                        this.calibrationFlag = true;
                    }

                    if (this.calibrationFlag) {
                        this.calibrationFlag = false;
                        this.calibrationX = x;
                        this.calibrationY = y;
                    }

                    this.inputX = x;
                    this.inputY = y;
                }
            }, {
                key: 'onDeviceOrientation',
                value: function onDeviceOrientation(event) {
                    var beta = event.beta;
                    var gamma = event.gamma;
                    if (beta !== null && gamma !== null) {
                        this.orientationStatus = 1;
                        this.rotate(beta, gamma);
                    }
                }
            }, {
                key: 'onDeviceMotion',
                value: function onDeviceMotion(event) {
                    var beta = event.rotationRate.beta;
                    var gamma = event.rotationRate.gamma;
                    if (beta !== null && gamma !== null) {
                        this.motionStatus = 1;
                        this.rotate(beta, gamma);
                    }
                }
            }, {
                key: 'onMouseMove',
                value: function onMouseMove(event) {
                    var clientX = event.clientX,
                        clientY = event.clientY;

                    // reset input to center if hoverOnly is set and we're not hovering the element
                    if (this.hoverOnly && (clientX < this.elementPositionX || clientX > this.elementPositionX + this.elementWidth || clientY < this.elementPositionY || clientY > this.elementPositionY + this.elementHeight)) {
                        this.inputX = 0;
                        this.inputY = 0;
                        return;
                    }

                    if (this.relativeInput) {
                        // Clip mouse coordinates inside element bounds.
                        if (this.clipRelativeInput) {
                            clientX = Math.max(clientX, this.elementPositionX);
                            clientX = Math.min(clientX, this.elementPositionX + this.elementWidth);
                            clientY = Math.max(clientY, this.elementPositionY);
                            clientY = Math.min(clientY, this.elementPositionY + this.elementHeight);
                        }
                        // Calculate input relative to the element.
                        if (this.elementRangeX && this.elementRangeY) {
                            this.inputX = (clientX - this.elementPositionX - this.elementCenterX) / this.elementRangeX;
                            this.inputY = (clientY - this.elementPositionY - this.elementCenterY) / this.elementRangeY;
                        }
                    } else {
                        // Calculate input relative to the window.
                        if (this.windowRadiusX && this.windowRadiusY) {
                            this.inputX = (clientX - this.windowCenterX) / this.windowRadiusX;
                            this.inputY = (clientY - this.windowCenterY) / this.windowRadiusY;
                        }
                    }
                }
            }, {
                key: 'destroy',
                value: function destroy() {
                    this.disable();

                    clearTimeout(this.calibrationTimer);
                    clearTimeout(this.detectionTimer);

                    this.element.removeAttribute('style');
                    for (var index = 0; index < this.layers.length; index++) {
                        this.layers[index].removeAttribute('style');
                    }

                    delete this.element;
                    delete this.layers;
                }
            }, {
                key: 'version',
                value: function version() {
                    return '3.1.0';
                }
            }]);

            return Parallax;
        }();

        module.exports = Parallax;

    },{"object-assign":1,"raf":4}]},{},[5])(5)
});








/*!
 * parallax.js v1.5.0 (http://pixelcog.github.io/parallax.js/)
 * @copyright 2016 PixelCog, Inc.
 * @license MIT (https://github.com/pixelcog/parallax.js/blob/master/LICENSE)
 */

;(function ( $, window, document, undefined ) {

    // Polyfill for requestAnimationFrame
    // via: https://gist.github.com/paulirish/1579671

    (function() {
        var lastTime = 0;
        var vendors = ['ms', 'moz', 'webkit', 'o'];
        for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
            window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
            window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
        }

        if (!window.requestAnimationFrame)
            window.requestAnimationFrame = function(callback) {
                var currTime = new Date().getTime();
                var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                var id = window.setTimeout(function() { callback(currTime + timeToCall); },
                    timeToCall);
                lastTime = currTime + timeToCall;
                return id;
            };

        if (!window.cancelAnimationFrame)
            window.cancelAnimationFrame = function(id) {
                clearTimeout(id);
            };
    }());


    // Parallax Constructor

    function Parallax(element, options) {
        var self = this;

        if (typeof options == 'object') {
            delete options.refresh;
            delete options.render;
            $.extend(this, options);
        }

        this.$element = $(element);

        if (!this.imageSrc && this.$element.is('img')) {
            this.imageSrc = this.$element.attr('src');
        }

        var positions = (this.position + '').toLowerCase().match(/\S+/g) || [];

        if (positions.length < 1) {
            positions.push('center');
        }
        if (positions.length == 1) {
            positions.push(positions[0]);
        }

        if (positions[0] == 'top' || positions[0] == 'bottom' || positions[1] == 'left' || positions[1] == 'right') {
            positions = [positions[1], positions[0]];
        }

        if (this.positionX !== undefined) positions[0] = this.positionX.toLowerCase();
        if (this.positionY !== undefined) positions[1] = this.positionY.toLowerCase();

        self.positionX = positions[0];
        self.positionY = positions[1];

        if (this.positionX != 'left' && this.positionX != 'right') {
            if (isNaN(parseInt(this.positionX))) {
                this.positionX = 'center';
            } else {
                this.positionX = parseInt(this.positionX);
            }
        }

        if (this.positionY != 'top' && this.positionY != 'bottom') {
            if (isNaN(parseInt(this.positionY))) {
                this.positionY = 'center';
            } else {
                this.positionY = parseInt(this.positionY);
            }
        }

        this.position =
            this.positionX + (isNaN(this.positionX)? '' : 'px') + ' ' +
            this.positionY + (isNaN(this.positionY)? '' : 'px');

        if (navigator.userAgent.match(/(iPod|iPhone|iPad)/)) {
            if (this.imageSrc && this.iosFix && !this.$element.is('img')) {
                this.$element.css({
                    backgroundImage: 'url(' + this.imageSrc + ')',
                    backgroundSize: 'cover',
                    backgroundPosition: this.position
                });
            }
            return this;
        }

        if (navigator.userAgent.match(/(Android)/)) {
            if (this.imageSrc && this.androidFix && !this.$element.is('img')) {
                this.$element.css({
                    backgroundImage: 'url(' + this.imageSrc + ')',
                    backgroundSize: 'cover',
                    backgroundPosition: this.position
                });
            }
            return this;
        }

        this.$mirror = $('<div />').prependTo(this.mirrorContainer);

        var slider = this.$element.find('>.parallax-slider');
        var sliderExisted = false;

        if (slider.length == 0)
            this.$slider = $('<img />').prependTo(this.$mirror);
        else {
            this.$slider = slider.prependTo(this.$mirror)
            sliderExisted = true;
        }

        this.$mirror.addClass('parallax-mirror').css({
            visibility: 'hidden',
            zIndex: this.zIndex,
            position: 'fixed',
            top: 0,
            left: 0,
            overflow: 'hidden'
        });

        this.$slider.addClass('parallax-slider').one('load', function() {
            if (!self.naturalHeight || !self.naturalWidth) {
                self.naturalHeight = this.naturalHeight || this.height || 1;
                self.naturalWidth  = this.naturalWidth  || this.width  || 1;
            }
            self.aspectRatio = self.naturalWidth / self.naturalHeight;

            Parallax.isSetup || Parallax.setup();
            Parallax.sliders.push(self);
            Parallax.isFresh = false;
            Parallax.requestRender();
        });

        if (!sliderExisted)
            this.$slider[0].src = this.imageSrc;

        if (this.naturalHeight && this.naturalWidth || this.$slider[0].complete || slider.length > 0) {
            this.$slider.trigger('load');
        }

    }


    // Parallax Instance Methods

    $.extend(Parallax.prototype, {
        speed:    0.2,
        bleed:    0,
        zIndex:   -100,
        iosFix:   true,
        androidFix: true,
        position: 'center',
        overScrollFix: false,
        mirrorContainer: 'body',

        refresh: function() {
            this.boxWidth        = this.$element.outerWidth();
            this.boxHeight       = this.$element.outerHeight() + this.bleed * 2;
            this.boxOffsetTop    = this.$element.offset().top - this.bleed;
            this.boxOffsetLeft   = this.$element.offset().left;
            this.boxOffsetBottom = this.boxOffsetTop + this.boxHeight;

            var winHeight = Parallax.winHeight;
            var docHeight = Parallax.docHeight;
            var maxOffset = Math.min(this.boxOffsetTop, docHeight - winHeight);
            var minOffset = Math.max(this.boxOffsetTop + this.boxHeight - winHeight, 0);
            var imageHeightMin = this.boxHeight + (maxOffset - minOffset) * (1 - this.speed) | 0;
            var imageOffsetMin = (this.boxOffsetTop - maxOffset) * (1 - this.speed) | 0;
            var margin;

            if (imageHeightMin * this.aspectRatio >= this.boxWidth) {
                this.imageWidth    = imageHeightMin * this.aspectRatio | 0;
                this.imageHeight   = imageHeightMin;
                this.offsetBaseTop = imageOffsetMin;

                margin = this.imageWidth - this.boxWidth;

                if (this.positionX == 'left') {
                    this.offsetLeft = 0;
                } else if (this.positionX == 'right') {
                    this.offsetLeft = - margin;
                } else if (!isNaN(this.positionX)) {
                    this.offsetLeft = Math.max(this.positionX, - margin);
                } else {
                    this.offsetLeft = - margin / 2 | 0;
                }
            } else {
                this.imageWidth    = this.boxWidth;
                this.imageHeight   = this.boxWidth / this.aspectRatio | 0;
                this.offsetLeft    = 0;

                margin = this.imageHeight - imageHeightMin;

                if (this.positionY == 'top') {
                    this.offsetBaseTop = imageOffsetMin;
                } else if (this.positionY == 'bottom') {
                    this.offsetBaseTop = imageOffsetMin - margin;
                } else if (!isNaN(this.positionY)) {
                    this.offsetBaseTop = imageOffsetMin + Math.max(this.positionY, - margin);
                } else {
                    this.offsetBaseTop = imageOffsetMin - margin / 2 | 0;
                }
            }
        },

        render: function() {
            var scrollTop    = Parallax.scrollTop;
            var scrollLeft   = Parallax.scrollLeft;
            var overScroll   = this.overScrollFix ? Parallax.overScroll : 0;
            var scrollBottom = scrollTop + Parallax.winHeight;

            if (this.boxOffsetBottom > scrollTop && this.boxOffsetTop <= scrollBottom) {
                this.visibility = 'visible';
                this.mirrorTop = this.boxOffsetTop  - scrollTop;
                this.mirrorLeft = this.boxOffsetLeft - scrollLeft;
                this.offsetTop = this.offsetBaseTop - this.mirrorTop * (1 - this.speed);
            } else {
                this.visibility = 'hidden';
            }

            this.$mirror.css({
                transform: 'translate3d('+this.mirrorLeft+'px, '+(this.mirrorTop - overScroll)+'px, 0px)',
                visibility: this.visibility,
                height: this.boxHeight,
                width: this.boxWidth
            });

            this.$slider.css({
                transform: 'translate3d('+this.offsetLeft+'px, '+this.offsetTop+'px, 0px)',
                position: 'absolute',
                height: this.imageHeight,
                width: this.imageWidth,
                maxWidth: 'none'
            });
        }
    });


    // Parallax Static Methods

    $.extend(Parallax, {
        scrollTop:    0,
        scrollLeft:   0,
        winHeight:    0,
        winWidth:     0,
        docHeight:    1 << 30,
        docWidth:     1 << 30,
        sliders:      [],
        isReady:      false,
        isFresh:      false,
        isBusy:       false,

        setup: function() {
            if (this.isReady) return;

            var self = this;

            var $doc = $(document), $win = $(window);

            var loadDimensions = function() {
                Parallax.winHeight = $win.height();
                Parallax.winWidth  = $win.width();
                Parallax.docHeight = $doc.height();
                Parallax.docWidth  = $doc.width();
            };

            var loadScrollPosition = function() {
                var winScrollTop  = $win.scrollTop();
                var scrollTopMax  = Parallax.docHeight - Parallax.winHeight;
                var scrollLeftMax = Parallax.docWidth  - Parallax.winWidth;
                Parallax.scrollTop  = Math.max(0, Math.min(scrollTopMax,  winScrollTop));
                Parallax.scrollLeft = Math.max(0, Math.min(scrollLeftMax, $win.scrollLeft()));
                Parallax.overScroll = Math.max(winScrollTop - scrollTopMax, Math.min(winScrollTop, 0));
            };

            $win.on('resize.px.parallax load.px.parallax', function() {
                loadDimensions();
                self.refresh();
                Parallax.isFresh = false;
                Parallax.requestRender();
            })
                .on('scroll.px.parallax load.px.parallax', function() {
                    loadScrollPosition();
                    Parallax.requestRender();
                });

            loadDimensions();
            loadScrollPosition();

            this.isReady = true;

            var lastPosition = -1;

            function frameLoop() {
                if (lastPosition == window.pageYOffset) {   // Avoid overcalculations
                    window.requestAnimationFrame(frameLoop);
                    return false;
                } else lastPosition = window.pageYOffset;

                self.render();
                window.requestAnimationFrame(frameLoop);
            }

            frameLoop();
        },

        configure: function(options) {
            if (typeof options == 'object') {
                delete options.refresh;
                delete options.render;
                $.extend(this.prototype, options);
            }
        },

        refresh: function() {
            $.each(this.sliders, function(){ this.refresh(); });
            this.isFresh = true;
        },

        render: function() {
            this.isFresh || this.refresh();
            $.each(this.sliders, function(){ this.render(); });
        },

        requestRender: function() {
            var self = this;
            self.render();
            self.isBusy = false;
        },
        destroy: function(el){
            var i,
                parallaxElement = $(el).data('px.parallax');
            parallaxElement.$mirror.remove();
            for(i=0; i < this.sliders.length; i+=1){
                if(this.sliders[i] == parallaxElement){
                    this.sliders.splice(i, 1);
                }
            }
            $(el).data('px.parallax', false);
            if(this.sliders.length === 0){
                $(window).off('scroll.px.parallax resize.px.parallax load.px.parallax');
                this.isReady = false;
                Parallax.isSetup = false;
            }
        }
    });


    // Parallax Plugin Definition

    function Plugin(option) {
        return this.each(function () {
            var $this = $(this);
            var options = typeof option == 'object' && option;

            if (this == window || this == document || $this.is('body')) {
                Parallax.configure(options);
            }
            else if (!$this.data('px.parallax')) {
                options = $.extend({}, $this.data(), options);
                $this.data('px.parallax', new Parallax(this, options));
            }
            else if (typeof option == 'object')
            {
                $.extend($this.data('px.parallax'), options);
            }
            if (typeof option == 'string') {
                if(option == 'destroy'){
                    Parallax.destroy(this);
                }else{
                    Parallax[option]();
                }
            }
        });
    }

    var old = $.fn.parallax;

    $.fn.parallax             = Plugin;
    $.fn.parallax.Constructor = Parallax;


    // Parallax No Conflict

    $.fn.parallax.noConflict = function () {
        $.fn.parallax = old;
        return this;
    };


    // Parallax Data-API

    $( function () {
        $('[data-parallax="scroll"]').parallax();
    });

}(jQuery, window, document));

$(function() {

    $('.parallax-window').parallax({imageSrc: '../img/main-section-bg.png'});
    var scene = document.getElementById('scene');
    var parallaxInstance = new Parallax(scene, {
        relativeInput: true
    });

    var scene2 = document.getElementById('scene2');
    var parallaxInstance = new Parallax(scene2, {
        relativeInput: true
    });

    var scene1 = document.getElementById('scene1');
    var parallaxInstance = new Parallax(scene1, {
        relativeInput: true,

    });
    var scene3 = document.getElementById('scene3');
    var parallaxInstance = new Parallax(scene3, {
        relativeInput: true
    });
    var scene4 = document.getElementById('scene4');
    var parallaxInstance = new Parallax(scene4, {
        relativeInput: true
    });
    var scene5 = document.getElementById('scene5');
    var parallaxInstance = new Parallax(scene5, {
        relativeInput: true
    });
    var scene6 = document.getElementById('scene6');
    var parallaxInstance = new Parallax(scene6, {
        relativeInput: true
    });
    var scene7 = document.getElementById('scene7');
    var parallaxInstance = new Parallax(scene7, {
        relativeInput: true
    });

    $("input,textarea").jqBootstrapValidation({
        preventSubmit: true,
        submitError: function($form, event, errors) {
            // additional error messages or events
        },
        submitSuccess: function($form, event) {
            event.preventDefault(); // prevent default submit behaviour
            // get values from FORM
            var name = $("input#name").val();
            var email = $("input#email").val();
            var phone = $("input#phone").val();
            var message = $("textarea#message").val();
            var firstName = name; // For Success/Failure Message
            // Check for white space in name for Success/Fail message
            if (firstName.indexOf(' ') >= 0) {
                firstName = name.split(' ').slice(0, -1).join(' ');
            }
            $.ajax({
                url: "././mail/contact_me.php",
                type: "POST",
                data: {
                    name: name,
                    phone: phone,
                    email: email,
                    message: message
                },
                cache: false,
                success: function() {
                    // Success message
                    $('#success').html("<div class='alert alert-success'>");
                    $('#success > .alert-success').html("<button type='button' class='close' data-dismiss='alert' aria-hidden='true'>&times;")
                        .append("</button>");
                    $('#success > .alert-success')
                        .append("<strong>Your message has been sent. </strong>");
                    $('#success > .alert-success')
                        .append('</div>');

                    //clear all fields
                    $('#contactForm').trigger("reset");
                },
                error: function() {
                    // Fail message
                    $('#success').html("<div class='alert alert-danger'>");
                    $('#success > .alert-danger').html("<button type='button' class='close' data-dismiss='alert' aria-hidden='true'>&times;")
                        .append("</button>");
                    $('#success > .alert-danger').append("<strong>Sorry " + firstName + ", it seems that my mail server is not responding. Please try again later!");
                    $('#success > .alert-danger').append('</div>');
                    //clear all fields
                    $('#contactForm').trigger("reset");
                },
            })
        },
        filter: function() {
            return $(this).is(":visible");
        },
    });

    $("a[data-toggle=\"tab\"]").click(function(e) {
        e.preventDefault();
        $(this).tab("show");
    });
});


/*When clicking on Full hide fail/success boxes */
$('#name').focus(function() {
    $('#success').html('');
});

// jqBootstrapValidation
// * A plugin for automating validation on Twitter Bootstrap formatted forms.
// *
// * v1.3.6
// *
// * License: MIT <http://opensource.org/licenses/mit-license.php> - see LICENSE file
// *
// * http://ReactiveRaven.github.com/jqBootstrapValidation/


(function( $ ){

    var createdElements = [];

    var defaults = {
        options: {
            prependExistingHelpBlock: false,
            sniffHtml: true, // sniff for 'required', 'maxlength', etc
            preventSubmit: true, // stop the form submit event from firing if validation fails
            submitError: false, // function called if there is an error when trying to submit
            submitSuccess: false, // function called just before a successful submit event is sent to the server
            semanticallyStrict: false, // set to true to tidy up generated HTML output
            autoAdd: {
                helpBlocks: true
            },
            filter: function () {
                // return $(this).is(":visible"); // only validate elements you can see
                return true; // validate everything
            }
        },
        methods: {
            init : function( options ) {

                var settings = $.extend(true, {}, defaults);

                settings.options = $.extend(true, settings.options, options);

                var $siblingElements = this;

                var uniqueForms = $.unique(
                    $siblingElements.map( function () {
                        return $(this).parents("form")[0];
                    }).toArray()
                );

                $(uniqueForms).bind("submit", function (e) {
                    var $form = $(this);
                    var warningsFound = 0;
                    var $inputs = $form.find("input,textarea,select").not("[type=submit],[type=image]").filter(settings.options.filter);
                    $inputs.trigger("submit.validation").trigger("validationLostFocus.validation");

                    $inputs.each(function (i, el) {
                        var $this = $(el),
                            $controlGroup = $this.parents(".form-group").first();
                        if (
                            $controlGroup.hasClass("warning")
                        ) {
                            $controlGroup.removeClass("warning").addClass("error");
                            warningsFound++;
                        }
                    });

                    $inputs.trigger("validationLostFocus.validation");

                    if (warningsFound) {
                        if (settings.options.preventSubmit) {
                            e.preventDefault();
                        }
                        $form.addClass("error");
                        if ($.isFunction(settings.options.submitError)) {
                            settings.options.submitError($form, e, $inputs.jqBootstrapValidation("collectErrors", true));
                        }
                    } else {
                        $form.removeClass("error");
                        if ($.isFunction(settings.options.submitSuccess)) {
                            settings.options.submitSuccess($form, e);
                        }
                    }
                });

                return this.each(function(){

                    // Get references to everything we're interested in
                    var $this = $(this),
                        $controlGroup = $this.parents(".form-group").first(),
                        $helpBlock = $controlGroup.find(".help-block").first(),
                        $form = $this.parents("form").first(),
                        validatorNames = [];

                    // create message container if not exists
                    if (!$helpBlock.length && settings.options.autoAdd && settings.options.autoAdd.helpBlocks) {
                        $helpBlock = $('<div class="help-block" />');
                        $controlGroup.find('.controls').append($helpBlock);
                        createdElements.push($helpBlock[0]);
                    }

                    // =============================================================
                    //                                     SNIFF HTML FOR VALIDATORS
                    // =============================================================

                    // *snort sniff snuffle*

                    if (settings.options.sniffHtml) {
                        var message = "";
                        // ---------------------------------------------------------
                        //                                                   PATTERN
                        // ---------------------------------------------------------
                        if ($this.attr("pattern") !== undefined) {
                            message = "Not in the expected format<!-- data-validation-pattern-message to override -->";
                            if ($this.data("validationPatternMessage")) {
                                message = $this.data("validationPatternMessage");
                            }
                            $this.data("validationPatternMessage", message);
                            $this.data("validationPatternRegex", $this.attr("pattern"));
                        }
                        // ---------------------------------------------------------
                        //                                                       MAX
                        // ---------------------------------------------------------
                        if ($this.attr("max") !== undefined || $this.attr("aria-valuemax") !== undefined) {
                            var max = ($this.attr("max") !== undefined ? $this.attr("max") : $this.attr("aria-valuemax"));
                            message = "Too high: Maximum of '" + max + "'<!-- data-validation-max-message to override -->";
                            if ($this.data("validationMaxMessage")) {
                                message = $this.data("validationMaxMessage");
                            }
                            $this.data("validationMaxMessage", message);
                            $this.data("validationMaxMax", max);
                        }
                        // ---------------------------------------------------------
                        //                                                       MIN
                        // ---------------------------------------------------------
                        if ($this.attr("min") !== undefined || $this.attr("aria-valuemin") !== undefined) {
                            var min = ($this.attr("min") !== undefined ? $this.attr("min") : $this.attr("aria-valuemin"));
                            message = "Too low: Minimum of '" + min + "'<!-- data-validation-min-message to override -->";
                            if ($this.data("validationMinMessage")) {
                                message = $this.data("validationMinMessage");
                            }
                            $this.data("validationMinMessage", message);
                            $this.data("validationMinMin", min);
                        }
                        // ---------------------------------------------------------
                        //                                                 MAXLENGTH
                        // ---------------------------------------------------------
                        if ($this.attr("maxlength") !== undefined) {
                            message = "Too long: Maximum of '" + $this.attr("maxlength") + "' characters<!-- data-validation-maxlength-message to override -->";
                            if ($this.data("validationMaxlengthMessage")) {
                                message = $this.data("validationMaxlengthMessage");
                            }
                            $this.data("validationMaxlengthMessage", message);
                            $this.data("validationMaxlengthMaxlength", $this.attr("maxlength"));
                        }
                        // ---------------------------------------------------------
                        //                                                 MINLENGTH
                        // ---------------------------------------------------------
                        if ($this.attr("minlength") !== undefined) {
                            message = "Too short: Minimum of '" + $this.attr("minlength") + "' characters<!-- data-validation-minlength-message to override -->";
                            if ($this.data("validationMinlengthMessage")) {
                                message = $this.data("validationMinlengthMessage");
                            }
                            $this.data("validationMinlengthMessage", message);
                            $this.data("validationMinlengthMinlength", $this.attr("minlength"));
                        }
                        // ---------------------------------------------------------
                        //                                                  REQUIRED
                        // ---------------------------------------------------------
                        if ($this.attr("required") !== undefined || $this.attr("aria-required") !== undefined) {
                            message = settings.builtInValidators.required.message;
                            if ($this.data("validationRequiredMessage")) {
                                message = $this.data("validationRequiredMessage");
                            }
                            $this.data("validationRequiredMessage", message);
                        }
                        // ---------------------------------------------------------
                        //                                                    NUMBER
                        // ---------------------------------------------------------
                        if ($this.attr("type") !== undefined && $this.attr("type").toLowerCase() === "number") {
                            message = settings.builtInValidators.number.message;
                            if ($this.data("validationNumberMessage")) {
                                message = $this.data("validationNumberMessage");
                            }
                            $this.data("validationNumberMessage", message);
                        }
                        // ---------------------------------------------------------
                        //                                                     EMAIL
                        // ---------------------------------------------------------
                        if ($this.attr("type") !== undefined && $this.attr("type").toLowerCase() === "email") {
                            message = "Not a valid email address<!-- data-validator-validemail-message to override -->";
                            if ($this.data("validationValidemailMessage")) {
                                message = $this.data("validationValidemailMessage");
                            } else if ($this.data("validationEmailMessage")) {
                                message = $this.data("validationEmailMessage");
                            }
                            $this.data("validationValidemailMessage", message);
                        }
                        // ---------------------------------------------------------
                        //                                                MINCHECKED
                        // ---------------------------------------------------------
                        if ($this.attr("minchecked") !== undefined) {
                            message = "Not enough options checked; Minimum of '" + $this.attr("minchecked") + "' required<!-- data-validation-minchecked-message to override -->";
                            if ($this.data("validationMincheckedMessage")) {
                                message = $this.data("validationMincheckedMessage");
                            }
                            $this.data("validationMincheckedMessage", message);
                            $this.data("validationMincheckedMinchecked", $this.attr("minchecked"));
                        }
                        // ---------------------------------------------------------
                        //                                                MAXCHECKED
                        // ---------------------------------------------------------
                        if ($this.attr("maxchecked") !== undefined) {
                            message = "Too many options checked; Maximum of '" + $this.attr("maxchecked") + "' required<!-- data-validation-maxchecked-message to override -->";
                            if ($this.data("validationMaxcheckedMessage")) {
                                message = $this.data("validationMaxcheckedMessage");
                            }
                            $this.data("validationMaxcheckedMessage", message);
                            $this.data("validationMaxcheckedMaxchecked", $this.attr("maxchecked"));
                        }
                    }

                    // =============================================================
                    //                                       COLLECT VALIDATOR NAMES
                    // =============================================================

                    // Get named validators
                    if ($this.data("validation") !== undefined) {
                        validatorNames = $this.data("validation").split(",");
                    }

                    // Get extra ones defined on the element's data attributes
                    $.each($this.data(), function (i, el) {
                        var parts = i.replace(/([A-Z])/g, ",$1").split(",");
                        if (parts[0] === "validation" && parts[1]) {
                            validatorNames.push(parts[1]);
                        }
                    });

                    // =============================================================
                    //                                     NORMALISE VALIDATOR NAMES
                    // =============================================================

                    var validatorNamesToInspect = validatorNames;
                    var newValidatorNamesToInspect = [];

                    do // repeatedly expand 'shortcut' validators into their real validators
                    {
                        // Uppercase only the first letter of each name
                        $.each(validatorNames, function (i, el) {
                            validatorNames[i] = formatValidatorName(el);
                        });

                        // Remove duplicate validator names
                        validatorNames = $.unique(validatorNames);

                        // Pull out the new validator names from each shortcut
                        newValidatorNamesToInspect = [];
                        $.each(validatorNamesToInspect, function(i, el) {
                            if ($this.data("validation" + el + "Shortcut") !== undefined) {
                                // Are these custom validators?
                                // Pull them out!
                                $.each($this.data("validation" + el + "Shortcut").split(","), function(i2, el2) {
                                    newValidatorNamesToInspect.push(el2);
                                });
                            } else if (settings.builtInValidators[el.toLowerCase()]) {
                                // Is this a recognised built-in?
                                // Pull it out!
                                var validator = settings.builtInValidators[el.toLowerCase()];
                                if (validator.type.toLowerCase() === "shortcut") {
                                    $.each(validator.shortcut.split(","), function (i, el) {
                                        el = formatValidatorName(el);
                                        newValidatorNamesToInspect.push(el);
                                        validatorNames.push(el);
                                    });
                                }
                            }
                        });

                        validatorNamesToInspect = newValidatorNamesToInspect;

                    } while (validatorNamesToInspect.length > 0)

                    // =============================================================
                    //                                       SET UP VALIDATOR ARRAYS
                    // =============================================================

                    var validators = {};

                    $.each(validatorNames, function (i, el) {
                        // Set up the 'override' message
                        var message = $this.data("validation" + el + "Message");
                        var hasOverrideMessage = (message !== undefined);
                        var foundValidator = false;
                        message =
                            (
                                message
                                    ? message
                                    : "'" + el + "' validation failed <!-- Add attribute 'data-validation-" + el.toLowerCase() + "-message' to input to change this message -->"
                            )
                        ;

                        $.each(
                            settings.validatorTypes,
                            function (validatorType, validatorTemplate) {
                                if (validators[validatorType] === undefined) {
                                    validators[validatorType] = [];
                                }
                                if (!foundValidator && $this.data("validation" + el + formatValidatorName(validatorTemplate.name)) !== undefined) {
                                    validators[validatorType].push(
                                        $.extend(
                                            true,
                                            {
                                                name: formatValidatorName(validatorTemplate.name),
                                                message: message
                                            },
                                            validatorTemplate.init($this, el)
                                        )
                                    );
                                    foundValidator = true;
                                }
                            }
                        );

                        if (!foundValidator && settings.builtInValidators[el.toLowerCase()]) {

                            var validator = $.extend(true, {}, settings.builtInValidators[el.toLowerCase()]);
                            if (hasOverrideMessage) {
                                validator.message = message;
                            }
                            var validatorType = validator.type.toLowerCase();

                            if (validatorType === "shortcut") {
                                foundValidator = true;
                            } else {
                                $.each(
                                    settings.validatorTypes,
                                    function (validatorTemplateType, validatorTemplate) {
                                        if (validators[validatorTemplateType] === undefined) {
                                            validators[validatorTemplateType] = [];
                                        }
                                        if (!foundValidator && validatorType === validatorTemplateType.toLowerCase()) {
                                            $this.data("validation" + el + formatValidatorName(validatorTemplate.name), validator[validatorTemplate.name.toLowerCase()]);
                                            validators[validatorType].push(
                                                $.extend(
                                                    validator,
                                                    validatorTemplate.init($this, el)
                                                )
                                            );
                                            foundValidator = true;
                                        }
                                    }
                                );
                            }
                        }

                        if (! foundValidator) {
                            $.error("Cannot find validation info for '" + el + "'");
                        }
                    });

                    // =============================================================
                    //                                         STORE FALLBACK VALUES
                    // =============================================================

                    $helpBlock.data(
                        "original-contents",
                        (
                            $helpBlock.data("original-contents")
                                ? $helpBlock.data("original-contents")
                                : $helpBlock.html()
                        )
                    );

                    $helpBlock.data(
                        "original-role",
                        (
                            $helpBlock.data("original-role")
                                ? $helpBlock.data("original-role")
                                : $helpBlock.attr("role")
                        )
                    );

                    $controlGroup.data(
                        "original-classes",
                        (
                            $controlGroup.data("original-clases")
                                ? $controlGroup.data("original-classes")
                                : $controlGroup.attr("class")
                        )
                    );

                    $this.data(
                        "original-aria-invalid",
                        (
                            $this.data("original-aria-invalid")
                                ? $this.data("original-aria-invalid")
                                : $this.attr("aria-invalid")
                        )
                    );

                    // =============================================================
                    //                                                    VALIDATION
                    // =============================================================

                    $this.bind(
                        "validation.validation",
                        function (event, params) {

                            var value = getValue($this);

                            // Get a list of the errors to apply
                            var errorsFound = [];

                            $.each(validators, function (validatorType, validatorTypeArray) {
                                if (value || value.length || (params && params.includeEmpty) || (!!settings.validatorTypes[validatorType].blockSubmit && params && !!params.submitting)) {
                                    $.each(validatorTypeArray, function (i, validator) {
                                        if (settings.validatorTypes[validatorType].validate($this, value, validator)) {
                                            errorsFound.push(validator.message);
                                        }
                                    });
                                }
                            });

                            return errorsFound;
                        }
                    );

                    $this.bind(
                        "getValidators.validation",
                        function () {
                            return validators;
                        }
                    );

                    // =============================================================
                    //                                             WATCH FOR CHANGES
                    // =============================================================
                    $this.bind(
                        "submit.validation",
                        function () {
                            return $this.triggerHandler("change.validation", {submitting: true});
                        }
                    );
                    $this.bind(
                        [
                            "keyup",
                            "focus",
                            "blur",
                            "click",
                            "keydown",
                            "keypress",
                            "change"
                        ].join(".validation ") + ".validation",
                        function (e, params) {

                            var value = getValue($this);

                            var errorsFound = [];

                            $controlGroup.find("input,textarea,select").each(function (i, el) {
                                var oldCount = errorsFound.length;
                                $.each($(el).triggerHandler("validation.validation", params), function (j, message) {
                                    errorsFound.push(message);
                                });
                                if (errorsFound.length > oldCount) {
                                    $(el).attr("aria-invalid", "true");
                                } else {
                                    var original = $this.data("original-aria-invalid");
                                    $(el).attr("aria-invalid", (original !== undefined ? original : false));
                                }
                            });

                            $form.find("input,select,textarea").not($this).not("[name=\"" + $this.attr("name") + "\"]").trigger("validationLostFocus.validation");

                            errorsFound = $.unique(errorsFound.sort());

                            // Were there any errors?
                            if (errorsFound.length) {
                                // Better flag it up as a warning.
                                $controlGroup.removeClass("success error").addClass("warning");

                                // How many errors did we find?
                                if (settings.options.semanticallyStrict && errorsFound.length === 1) {
                                    // Only one? Being strict? Just output it.
                                    $helpBlock.html(errorsFound[0] +
                                        ( settings.options.prependExistingHelpBlock ? $helpBlock.data("original-contents") : "" ));
                                } else {
                                    // Multiple? Being sloppy? Glue them together into an UL.
                                    $helpBlock.html("<ul role=\"alert\"><li>" + errorsFound.join("</li><li>") + "</li></ul>" +
                                        ( settings.options.prependExistingHelpBlock ? $helpBlock.data("original-contents") : "" ));
                                }
                            } else {
                                $controlGroup.removeClass("warning error success");
                                if (value.length > 0) {
                                    $controlGroup.addClass("success");
                                }
                                $helpBlock.html($helpBlock.data("original-contents"));
                            }

                            if (e.type === "blur") {
                                $controlGroup.removeClass("success");
                            }
                        }
                    );
                    $this.bind("validationLostFocus.validation", function () {
                        $controlGroup.removeClass("success");
                    });
                });
            },
            destroy : function( ) {

                return this.each(
                    function() {

                        var
                            $this = $(this),
                            $controlGroup = $this.parents(".form-group").first(),
                            $helpBlock = $controlGroup.find(".help-block").first();

                        // remove our events
                        $this.unbind('.validation'); // events are namespaced.
                        // reset help text
                        $helpBlock.html($helpBlock.data("original-contents"));
                        // reset classes
                        $controlGroup.attr("class", $controlGroup.data("original-classes"));
                        // reset aria
                        $this.attr("aria-invalid", $this.data("original-aria-invalid"));
                        // reset role
                        $helpBlock.attr("role", $this.data("original-role"));
                        // remove all elements we created
                        if (createdElements.indexOf($helpBlock[0]) > -1) {
                            $helpBlock.remove();
                        }

                    }
                );

            },
            collectErrors : function(includeEmpty) {

                var errorMessages = {};
                this.each(function (i, el) {
                    var $el = $(el);
                    var name = $el.attr("name");
                    var errors = $el.triggerHandler("validation.validation", {includeEmpty: true});
                    errorMessages[name] = $.extend(true, errors, errorMessages[name]);
                });

                $.each(errorMessages, function (i, el) {
                    if (el.length === 0) {
                        delete errorMessages[i];
                    }
                });

                return errorMessages;

            },
            hasErrors: function() {

                var errorMessages = [];

                this.each(function (i, el) {
                    errorMessages = errorMessages.concat(
                        $(el).triggerHandler("getValidators.validation") ? $(el).triggerHandler("validation.validation", {submitting: true}) : []
                    );
                });

                return (errorMessages.length > 0);
            },
            override : function (newDefaults) {
                defaults = $.extend(true, defaults, newDefaults);
            }
        },
        validatorTypes: {
            callback: {
                name: "callback",
                init: function ($this, name) {
                    return {
                        validatorName: name,
                        callback: $this.data("validation" + name + "Callback"),
                        lastValue: $this.val(),
                        lastValid: true,
                        lastFinished: true
                    };
                },
                validate: function ($this, value, validator) {
                    if (validator.lastValue === value && validator.lastFinished) {
                        return !validator.lastValid;
                    }

                    if (validator.lastFinished === true)
                    {
                        validator.lastValue = value;
                        validator.lastValid = true;
                        validator.lastFinished = false;

                        var rrjqbvValidator = validator;
                        var rrjqbvThis = $this;
                        executeFunctionByName(
                            validator.callback,
                            window,
                            $this,
                            value,
                            function (data) {
                                if (rrjqbvValidator.lastValue === data.value) {
                                    rrjqbvValidator.lastValid = data.valid;
                                    if (data.message) {
                                        rrjqbvValidator.message = data.message;
                                    }
                                    rrjqbvValidator.lastFinished = true;
                                    rrjqbvThis.data("validation" + rrjqbvValidator.validatorName + "Message", rrjqbvValidator.message);
                                    // Timeout is set to avoid problems with the events being considered 'already fired'
                                    setTimeout(function () {
                                        rrjqbvThis.trigger("change.validation");
                                    }, 1); // doesn't need a long timeout, just long enough for the event bubble to burst
                                }
                            }
                        );
                    }

                    return false;

                }
            },
            ajax: {
                name: "ajax",
                init: function ($this, name) {
                    return {
                        validatorName: name,
                        url: $this.data("validation" + name + "Ajax"),
                        lastValue: $this.val(),
                        lastValid: true,
                        lastFinished: true
                    };
                },
                validate: function ($this, value, validator) {
                    if (""+validator.lastValue === ""+value && validator.lastFinished === true) {
                        return validator.lastValid === false;
                    }

                    if (validator.lastFinished === true)
                    {
                        validator.lastValue = value;
                        validator.lastValid = true;
                        validator.lastFinished = false;
                        $.ajax({
                            url: validator.url,
                            data: "value=" + value + "&field=" + $this.attr("name"),
                            dataType: "json",
                            success: function (data) {
                                if (""+validator.lastValue === ""+data.value) {
                                    validator.lastValid = !!(data.valid);
                                    if (data.message) {
                                        validator.message = data.message;
                                    }
                                    validator.lastFinished = true;
                                    $this.data("validation" + validator.validatorName + "Message", validator.message);
                                    // Timeout is set to avoid problems with the events being considered 'already fired'
                                    setTimeout(function () {
                                        $this.trigger("change.validation");
                                    }, 1); // doesn't need a long timeout, just long enough for the event bubble to burst
                                }
                            },
                            failure: function () {
                                validator.lastValid = true;
                                validator.message = "ajax call failed";
                                validator.lastFinished = true;
                                $this.data("validation" + validator.validatorName + "Message", validator.message);
                                // Timeout is set to avoid problems with the events being considered 'already fired'
                                setTimeout(function () {
                                    $this.trigger("change.validation");
                                }, 1); // doesn't need a long timeout, just long enough for the event bubble to burst
                            }
                        });
                    }

                    return false;

                }
            },
            regex: {
                name: "regex",
                init: function ($this, name) {
                    return {regex: regexFromString($this.data("validation" + name + "Regex"))};
                },
                validate: function ($this, value, validator) {
                    return (!validator.regex.test(value) && ! validator.negative)
                        || (validator.regex.test(value) && validator.negative);
                }
            },
            required: {
                name: "required",
                init: function ($this, name) {
                    return {};
                },
                validate: function ($this, value, validator) {
                    return !!(value.length === 0  && ! validator.negative)
                        || !!(value.length > 0 && validator.negative);
                },
                blockSubmit: true
            },
            match: {
                name: "match",
                init: function ($this, name) {
                    var element = $this.parents("form").first().find("[name=\"" + $this.data("validation" + name + "Match") + "\"]").first();
                    element.bind("validation.validation", function () {
                        $this.trigger("change.validation", {submitting: true});
                    });
                    return {"element": element};
                },
                validate: function ($this, value, validator) {
                    return (value !== validator.element.val() && ! validator.negative)
                        || (value === validator.element.val() && validator.negative);
                },
                blockSubmit: true
            },
            max: {
                name: "max",
                init: function ($this, name) {
                    return {max: $this.data("validation" + name + "Max")};
                },
                validate: function ($this, value, validator) {
                    return (parseFloat(value, 10) > parseFloat(validator.max, 10) && ! validator.negative)
                        || (parseFloat(value, 10) <= parseFloat(validator.max, 10) && validator.negative);
                }
            },
            min: {
                name: "min",
                init: function ($this, name) {
                    return {min: $this.data("validation" + name + "Min")};
                },
                validate: function ($this, value, validator) {
                    return (parseFloat(value) < parseFloat(validator.min) && ! validator.negative)
                        || (parseFloat(value) >= parseFloat(validator.min) && validator.negative);
                }
            },
            maxlength: {
                name: "maxlength",
                init: function ($this, name) {
                    return {maxlength: $this.data("validation" + name + "Maxlength")};
                },
                validate: function ($this, value, validator) {
                    return ((value.length > validator.maxlength) && ! validator.negative)
                        || ((value.length <= validator.maxlength) && validator.negative);
                }
            },
            minlength: {
                name: "minlength",
                init: function ($this, name) {
                    return {minlength: $this.data("validation" + name + "Minlength")};
                },
                validate: function ($this, value, validator) {
                    return ((value.length < validator.minlength) && ! validator.negative)
                        || ((value.length >= validator.minlength) && validator.negative);
                }
            },
            maxchecked: {
                name: "maxchecked",
                init: function ($this, name) {
                    var elements = $this.parents("form").first().find("[name=\"" + $this.attr("name") + "\"]");
                    elements.bind("click.validation", function () {
                        $this.trigger("change.validation", {includeEmpty: true});
                    });
                    return {maxchecked: $this.data("validation" + name + "Maxchecked"), elements: elements};
                },
                validate: function ($this, value, validator) {
                    return (validator.elements.filter(":checked").length > validator.maxchecked && ! validator.negative)
                        || (validator.elements.filter(":checked").length <= validator.maxchecked && validator.negative);
                },
                blockSubmit: true
            },
            minchecked: {
                name: "minchecked",
                init: function ($this, name) {
                    var elements = $this.parents("form").first().find("[name=\"" + $this.attr("name") + "\"]");
                    elements.bind("click.validation", function () {
                        $this.trigger("change.validation", {includeEmpty: true});
                    });
                    return {minchecked: $this.data("validation" + name + "Minchecked"), elements: elements};
                },
                validate: function ($this, value, validator) {
                    return (validator.elements.filter(":checked").length < validator.minchecked && ! validator.negative)
                        || (validator.elements.filter(":checked").length >= validator.minchecked && validator.negative);
                },
                blockSubmit: true
            }
        },
        builtInValidators: {
            email: {
                name: "Email",
                type: "shortcut",
                shortcut: "validemail"
            },
            validemail: {
                name: "Validemail",
                type: "regex",
                regex: "[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\.[A-Za-z]{2,4}",
                message: "Not a valid email address<!-- data-validator-validemail-message to override -->"
            },
            passwordagain: {
                name: "Passwordagain",
                type: "match",
                match: "password",
                message: "Does not match the given password<!-- data-validator-paswordagain-message to override -->"
            },
            positive: {
                name: "Positive",
                type: "shortcut",
                shortcut: "number,positivenumber"
            },
            negative: {
                name: "Negative",
                type: "shortcut",
                shortcut: "number,negativenumber"
            },
            number: {
                name: "Number",
                type: "regex",
                regex: "([+-]?\\\d+(\\\.\\\d*)?([eE][+-]?[0-9]+)?)?",
                message: "Must be a number<!-- data-validator-number-message to override -->"
            },
            integer: {
                name: "Integer",
                type: "regex",
                regex: "[+-]?\\\d+",
                message: "No decimal places allowed<!-- data-validator-integer-message to override -->"
            },
            positivenumber: {
                name: "Positivenumber",
                type: "min",
                min: 0,
                message: "Must be a positive number<!-- data-validator-positivenumber-message to override -->"
            },
            negativenumber: {
                name: "Negativenumber",
                type: "max",
                max: 0,
                message: "Must be a negative number<!-- data-validator-negativenumber-message to override -->"
            },
            required: {
                name: "Required",
                type: "required",
                message: "This is required<!-- data-validator-required-message to override -->"
            },
            checkone: {
                name: "Checkone",
                type: "minchecked",
                minchecked: 1,
                message: "Check at least one option<!-- data-validation-checkone-message to override -->"
            }
        }
    };

    var formatValidatorName = function (name) {
        return name
            .toLowerCase()
            .replace(
                /(^|\s)([a-z])/g ,
                function(m,p1,p2) {
                    return p1+p2.toUpperCase();
                }
            )
            ;
    };

    var getValue = function ($this) {
        // Extract the value we're talking about
        var value = $this.val();
        var type = $this.attr("type");
        if (type === "checkbox") {
            value = ($this.is(":checked") ? value : "");
        }
        if (type === "radio") {
            value = ($('input[name="' + $this.attr("name") + '"]:checked').length > 0 ? value : "");
        }
        return value;
    };

    function regexFromString(inputstring) {
        return new RegExp("^" + inputstring + "$");
    }

    /**
     * Thanks to Jason Bunting via StackOverflow.com
     *
     * http://stackoverflow.com/questions/359788/how-to-execute-a-javascript-function-when-i-have-its-name-as-a-string#answer-359910
     * Short link: http://tinyurl.com/executeFunctionByName
     **/
    function executeFunctionByName(functionName, context /*, args*/) {
        var args = Array.prototype.slice.call(arguments).splice(2);
        var namespaces = functionName.split(".");
        var func = namespaces.pop();
        for(var i = 0; i < namespaces.length; i++) {
            context = context[namespaces[i]];
        }
        return context[func].apply(this, args);
    }

    $.fn.jqBootstrapValidation = function( method ) {

        if ( defaults.methods[method] ) {
            return defaults.methods[method].apply( this, Array.prototype.slice.call( arguments, 1 ));
        } else if ( typeof method === 'object' || ! method ) {
            return defaults.methods.init.apply( this, arguments );
        } else {
            $.error( 'Method ' +  method + ' does not exist on jQuery.jqBootstrapValidation' );
            return null;
        }

    };

    $.jqBootstrapValidation = function (options) {
        $(":input").not("[type=image],[type=submit]").jqBootstrapValidation.apply(this,arguments);
    };

})( jQuery );

// Floating label headings for the contact form
$(function() {
    $("body").on("input propertychange", ".floating-label-form-group", function(e) {
        $(this).toggleClass("floating-label-form-group-with-value", !!$(e.target).val());
    }).on("focus", ".floating-label-form-group", function() {
        $(this).addClass("floating-label-form-group-with-focus");
    }).on("blur", ".floating-label-form-group", function() {
        $(this).removeClass("floating-label-form-group-with-focus");
    });
});